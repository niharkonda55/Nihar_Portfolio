"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  getPath: () => getPath,
  mergePathStrings: () => mergePathStrings,
  pathArrayToString: () => pathArrayToString,
  setPath: () => setPath,
  stringToPathArray: () => stringToPathArray,
  toPathObject: () => toPathObject
});
module.exports = __toCommonJS(src_exports);

// src/stringToPathArray.ts
var stringToPathArray = (path) => {
  if (path.length === 0)
    return [];
  const match = path.match(/^\[(.+?)\](.*)$/) || path.match(/^\.?([^\.\[\]]+)(.*)$/);
  if (match) {
    const [_, key, rest] = match;
    return [/^\d+$/.test(key) ? Number(key) : key, ...stringToPathArray(rest)];
  }
  return [path];
};

// src/setPath.ts
function setPath(object, path, value) {
  const parts = Array.isArray(path) ? path : stringToPathArray(path);
  let obj = object;
  for (let i = 0; i < parts.length - 1; i++) {
    const part = parts[i];
    const nextPart = parts[i + 1];
    if (obj[part] === void 0) {
      if (typeof nextPart === "number") {
        obj[part] = [];
      } else {
        obj[part] = {};
      }
    }
    obj = obj[part];
  }
  obj[parts[parts.length - 1]] = value;
  return object;
}

// src/getPath.ts
var getPath = (object, path) => {
  const parts = Array.isArray(path) ? path : stringToPathArray(path);
  let value = object;
  for (const part of parts) {
    value = value?.[part];
  }
  return value;
};

// src/pathArrayToString.ts
var pathArrayToString = (path) => {
  if (path.length === 0)
    return "";
  let result = "";
  for (const item of path) {
    if (result === "") {
      result += `${item}`;
      continue;
    }
    const asNumber = Number(item);
    if (Number.isNaN(asNumber))
      result += `.${item}`;
    else
      result += `[${item}]`;
  }
  return result;
};

// src/toPathObject.ts
var toPathObject = (obj) => {
  const entries = getLeafEntries(obj, []);
  const flatEntries = entries.map(
    ([path, value]) => [pathArrayToString(path), value]
  );
  return Object.fromEntries(flatEntries);
};
var getLeafEntries = (obj, prefix) => {
  if (obj == null || typeof obj !== "object")
    return [[prefix, obj]];
  if (Array.isArray(obj))
    return obj.flatMap(
      (item, index) => getLeafEntries(item, [...prefix, index])
    );
  return Object.entries(obj).flatMap(
    ([key, value]) => getLeafEntries(value, [...prefix, key])
  );
};

// src/mergePathStrings.ts
var mergePathStrings = (...paths) => {
  return pathArrayToString(
    paths.filter((segment) => segment != null).map(String).flatMap(stringToPathArray).filter((segment) => segment !== "")
  );
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getPath,
  mergePathStrings,
  pathArrayToString,
  setPath,
  stringToPathArray,
  toPathObject
});
//# sourceMappingURL=index.cjs.js.map