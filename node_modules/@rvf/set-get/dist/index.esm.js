// src/stringToPathArray.ts
var stringToPathArray = (path) => {
  if (path.length === 0)
    return [];
  const match = path.match(/^\[(.+?)\](.*)$/) || path.match(/^\.?([^\.\[\]]+)(.*)$/);
  if (match) {
    const [_, key, rest] = match;
    return [/^\d+$/.test(key) ? Number(key) : key, ...stringToPathArray(rest)];
  }
  return [path];
};

// src/setPath.ts
function setPath(object, path, value) {
  const parts = Array.isArray(path) ? path : stringToPathArray(path);
  let obj = object;
  for (let i = 0; i < parts.length - 1; i++) {
    const part = parts[i];
    const nextPart = parts[i + 1];
    if (obj[part] === void 0) {
      if (typeof nextPart === "number") {
        obj[part] = [];
      } else {
        obj[part] = {};
      }
    }
    obj = obj[part];
  }
  obj[parts[parts.length - 1]] = value;
  return object;
}

// src/getPath.ts
var getPath = (object, path) => {
  const parts = Array.isArray(path) ? path : stringToPathArray(path);
  let value = object;
  for (const part of parts) {
    value = value?.[part];
  }
  return value;
};

// src/pathArrayToString.ts
var pathArrayToString = (path) => {
  if (path.length === 0)
    return "";
  let result = "";
  for (const item of path) {
    if (result === "") {
      result += `${item}`;
      continue;
    }
    const asNumber = Number(item);
    if (Number.isNaN(asNumber))
      result += `.${item}`;
    else
      result += `[${item}]`;
  }
  return result;
};

// src/toPathObject.ts
var toPathObject = (obj) => {
  const entries = getLeafEntries(obj, []);
  const flatEntries = entries.map(
    ([path, value]) => [pathArrayToString(path), value]
  );
  return Object.fromEntries(flatEntries);
};
var getLeafEntries = (obj, prefix) => {
  if (obj == null || typeof obj !== "object")
    return [[prefix, obj]];
  if (Array.isArray(obj))
    return obj.flatMap(
      (item, index) => getLeafEntries(item, [...prefix, index])
    );
  return Object.entries(obj).flatMap(
    ([key, value]) => getLeafEntries(value, [...prefix, key])
  );
};

// src/mergePathStrings.ts
var mergePathStrings = (...paths) => {
  return pathArrayToString(
    paths.filter((segment) => segment != null).map(String).flatMap(stringToPathArray).filter((segment) => segment !== "")
  );
};
export {
  getPath,
  mergePathStrings,
  pathArrayToString,
  setPath,
  stringToPathArray,
  toPathObject
};
//# sourceMappingURL=index.esm.js.map