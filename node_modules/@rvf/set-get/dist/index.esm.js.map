{"version":3,"sources":["../src/stringToPathArray.ts","../src/setPath.ts","../src/getPath.ts","../src/pathArrayToString.ts","../src/toPathObject.ts","../src/mergePathStrings.ts"],"sourcesContent":["export const stringToPathArray = <T extends string>(\n  path: T,\n): (string | number)[] => {\n  if (path.length === 0) return [];\n\n  const match =\n    path.match(/^\\[(.+?)\\](.*)$/) || path.match(/^\\.?([^\\.\\[\\]]+)(.*)$/);\n  if (match) {\n    const [_, key, rest] = match;\n    return [/^\\d+$/.test(key) ? Number(key) : key, ...stringToPathArray(rest)];\n  }\n  return [path];\n};\n","import { stringToPathArray } from \"./stringToPathArray\";\n\nexport function setPath<T>(\n  object: T,\n  path: string | (string | number)[],\n  value: unknown,\n) {\n  // deeply mutate the data\n  const parts = Array.isArray(path) ? path : stringToPathArray(path);\n  let obj: any = object;\n\n  for (let i = 0; i < parts.length - 1; i++) {\n    const part = parts[i];\n    const nextPart = parts[i + 1];\n    if (obj[part] === undefined) {\n      if (typeof nextPart === \"number\") {\n        obj[part] = [];\n      } else {\n        obj[part] = {};\n      }\n    }\n    obj = obj[part];\n  }\n\n  obj[parts[parts.length - 1]] = value;\n  return object;\n}\n","import { stringToPathArray } from \"./stringToPathArray\";\n\nexport const getPath = (object: any, path: string | (string | number)[]) => {\n  const parts = Array.isArray(path) ? path : stringToPathArray(path);\n  let value = object;\n  for (const part of parts) {\n    value = (value as any)?.[part];\n  }\n  return value;\n};\n","export const pathArrayToString = (path: (string | number)[]): string => {\n  if (path.length === 0) return \"\";\n\n  let result = \"\";\n  for (const item of path) {\n    if (result === \"\") {\n      result += `${item}`;\n      continue;\n    }\n\n    const asNumber = Number(item);\n    if (Number.isNaN(asNumber)) result += `.${item}`;\n    else result += `[${item}]`;\n  }\n\n  return result;\n};\n","import { pathArrayToString } from \"./pathArrayToString\";\n\nexport type GenericObject = { [key: string]: any };\n\nexport const toPathObject = (obj: GenericObject): Record<string, unknown> => {\n  const entries = getLeafEntries(obj, []);\n  const flatEntries = entries.map(\n    ([path, value]) => [pathArrayToString(path), value] as const,\n  );\n  return Object.fromEntries(flatEntries);\n};\n\ntype PathArray = (string | number)[];\n\nconst getLeafEntries = (\n  obj: unknown,\n  prefix: PathArray,\n): Array<[PathArray, unknown]> => {\n  if (obj == null || typeof obj !== \"object\") return [[prefix, obj]];\n  if (Array.isArray(obj))\n    return obj.flatMap((item, index) =>\n      getLeafEntries(item, [...prefix, index]),\n    );\n  return Object.entries(obj).flatMap(([key, value]) =>\n    getLeafEntries(value, [...prefix, key]),\n  );\n};\n","import { pathArrayToString } from \"./pathArrayToString\";\nimport { stringToPathArray } from \"./stringToPathArray\";\n\nexport const mergePathStrings = (\n  ...paths: (string | number | null | undefined)[]\n) => {\n  return pathArrayToString(\n    paths\n      .filter((segment) => segment != null)\n      .map(String)\n      .flatMap(stringToPathArray)\n      .filter((segment) => segment !== \"\"),\n  );\n};\n"],"mappings":";AAAO,IAAM,oBAAoB,CAC/B,SACwB;AACxB,MAAI,KAAK,WAAW;AAAG,WAAO,CAAC;AAE/B,QAAM,QACJ,KAAK,MAAM,iBAAiB,KAAK,KAAK,MAAM,uBAAuB;AACrE,MAAI,OAAO;AACT,UAAM,CAAC,GAAG,KAAK,IAAI,IAAI;AACvB,WAAO,CAAC,QAAQ,KAAK,GAAG,IAAI,OAAO,GAAG,IAAI,KAAK,GAAG,kBAAkB,IAAI,CAAC;AAAA,EAC3E;AACA,SAAO,CAAC,IAAI;AACd;;;ACVO,SAAS,QACd,QACA,MACA,OACA;AAEA,QAAM,QAAQ,MAAM,QAAQ,IAAI,IAAI,OAAO,kBAAkB,IAAI;AACjE,MAAI,MAAW;AAEf,WAAS,IAAI,GAAG,IAAI,MAAM,SAAS,GAAG,KAAK;AACzC,UAAM,OAAO,MAAM,CAAC;AACpB,UAAM,WAAW,MAAM,IAAI,CAAC;AAC5B,QAAI,IAAI,IAAI,MAAM,QAAW;AAC3B,UAAI,OAAO,aAAa,UAAU;AAChC,YAAI,IAAI,IAAI,CAAC;AAAA,MACf,OAAO;AACL,YAAI,IAAI,IAAI,CAAC;AAAA,MACf;AAAA,IACF;AACA,UAAM,IAAI,IAAI;AAAA,EAChB;AAEA,MAAI,MAAM,MAAM,SAAS,CAAC,CAAC,IAAI;AAC/B,SAAO;AACT;;;ACxBO,IAAM,UAAU,CAAC,QAAa,SAAuC;AAC1E,QAAM,QAAQ,MAAM,QAAQ,IAAI,IAAI,OAAO,kBAAkB,IAAI;AACjE,MAAI,QAAQ;AACZ,aAAW,QAAQ,OAAO;AACxB,YAAS,QAAgB,IAAI;AAAA,EAC/B;AACA,SAAO;AACT;;;ACTO,IAAM,oBAAoB,CAAC,SAAsC;AACtE,MAAI,KAAK,WAAW;AAAG,WAAO;AAE9B,MAAI,SAAS;AACb,aAAW,QAAQ,MAAM;AACvB,QAAI,WAAW,IAAI;AACjB,gBAAU,GAAG;AACb;AAAA,IACF;AAEA,UAAM,WAAW,OAAO,IAAI;AAC5B,QAAI,OAAO,MAAM,QAAQ;AAAG,gBAAU,IAAI;AAAA;AACrC,gBAAU,IAAI;AAAA,EACrB;AAEA,SAAO;AACT;;;ACZO,IAAM,eAAe,CAAC,QAAgD;AAC3E,QAAM,UAAU,eAAe,KAAK,CAAC,CAAC;AACtC,QAAM,cAAc,QAAQ;AAAA,IAC1B,CAAC,CAAC,MAAM,KAAK,MAAM,CAAC,kBAAkB,IAAI,GAAG,KAAK;AAAA,EACpD;AACA,SAAO,OAAO,YAAY,WAAW;AACvC;AAIA,IAAM,iBAAiB,CACrB,KACA,WACgC;AAChC,MAAI,OAAO,QAAQ,OAAO,QAAQ;AAAU,WAAO,CAAC,CAAC,QAAQ,GAAG,CAAC;AACjE,MAAI,MAAM,QAAQ,GAAG;AACnB,WAAO,IAAI;AAAA,MAAQ,CAAC,MAAM,UACxB,eAAe,MAAM,CAAC,GAAG,QAAQ,KAAK,CAAC;AAAA,IACzC;AACF,SAAO,OAAO,QAAQ,GAAG,EAAE;AAAA,IAAQ,CAAC,CAAC,KAAK,KAAK,MAC7C,eAAe,OAAO,CAAC,GAAG,QAAQ,GAAG,CAAC;AAAA,EACxC;AACF;;;ACvBO,IAAM,mBAAmB,IAC3B,UACA;AACH,SAAO;AAAA,IACL,MACG,OAAO,CAAC,YAAY,WAAW,IAAI,EACnC,IAAI,MAAM,EACV,QAAQ,iBAAiB,EACzB,OAAO,CAAC,YAAY,YAAY,EAAE;AAAA,EACvC;AACF;","names":[]}